<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Generate MetaMask deeplinks for Home, Swap, Buy, and Predict Markets with pre-filled parameters.">
  <title>MetaMask Deeplink Generator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Euclid+Circular+B:wght@400;500;600;700&display=swap" rel="stylesheet">

  <style>
:root {
  --mm-orange: #F6851B;
  --mm-blue: #037DD6;
  --mm-blue-hover: #0260A4;
  --mm-green: #28A745;
  --mm-red: #D73A49;
  --mm-purple: #8B5CF6;

  --bg: #F2F4F6;
  --card: #FFFFFF;
  --muted: #6A737D;
  --text: #24272A;
  --accent: #037DD6;
  --border: #BBC0C5;
  --shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
  --shadow-hover: 0 8px 12px rgba(0, 0, 0, 0.12);
}

@media (prefers-color-scheme: dark) {
  :root {
    --bg: #141618;
    --card: #24272A;
    --muted: #9FA6AE;
    --text: #FFFFFF;
    --border: #3C4045;
    --shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
    --shadow-hover: 0 8px 12px rgba(0, 0, 0, 0.6);
  }
}

* { box-sizing: border-box; }

html, body {
  margin: 0;
  padding: 0;
  background: var(--bg);
  color: var(--text);
  font-family: 'Euclid Circular B', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  font-size: 14px;
  line-height: 1.6;
}

.header {
  background: var(--card);
  border-bottom: 1px solid var(--border);
  padding: 24px 0;
  margin-bottom: 32px;
  box-shadow: var(--shadow);
}

.header-content {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 24px;
  display: flex;
  align-items: center;
  gap: 16px;
}

.logo-img { 
  width: 48px; 
  height: 48px;
}

.wrap {
  max-width: 1400px;
  margin: 0 auto 32px;
  padding: 0 24px;
}

h1 {
  font-size: 28px;
  font-weight: 700;
  margin: 0;
  color: var(--text);
}

h2 {
  font-size: 20px;
  font-weight: 600;
  margin: 0 0 16px;
  color: var(--text);
}

.intro {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 20px 24px;
  margin-bottom: 24px;
  box-shadow: var(--shadow);
  color: var(--muted);
}

.grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 24px;
}

@media (max-width: 1200px) {
  .grid { grid-template-columns: repeat(2, 1fr); }
}

@media (max-width: 768px) {
  .grid { grid-template-columns: 1fr; }
}

.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 24px;
  box-shadow: var(--shadow);
  transition: all 0.2s ease;
}

.card:hover {
  box-shadow: var(--shadow-hover);
  transform: translateY(-2px);
}

label {
  display: block;
  margin: 12px 0 8px;
  color: var(--text);
  font-weight: 500;
  font-size: 14px;
}

select, input[type="text"], input[type="number"], textarea {
  width: 100%;
  padding: 12px 14px;
  border-radius: 10px;
  border: 1.5px solid var(--border);
  background: var(--bg);
  color: var(--text);
  font-size: 14px;
  font-family: inherit;
  transition: border-color 0.2s ease;
}

textarea {
  resize: vertical;
  min-height: 80px;
}

select:focus, input:focus, textarea:focus {
  outline: none;
  border-color: var(--accent);
}

input:disabled, textarea:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.input-with-toggle {
  position: relative;
}

.currency-toggle {
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--accent);
  color: white;
  border: none;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.currency-toggle:hover {
  background: var(--mm-blue-hover);
}

.conversion-info {
  font-size: 11px;
  color: var(--muted);
  margin-top: 4px;
  font-style: italic;
}

.btn {
  display: inline-flex;
  gap: 8px;
  align-items: center;
  justify-content: center;
  border: none;
  padding: 12px 20px;
  border-radius: 48px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  font-family: inherit;
  transition: all 0.2s ease;
}

.btn:hover { 
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.btn:active {
  transform: translateY(0);
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.btn-primary {
  background: var(--accent);
  color: white;
}
.btn-primary:hover { background: var(--mm-blue-hover); }

.btn-copy {
  background: var(--mm-green);
  color: white;
}

.btn-reset {
  background: var(--mm-orange);
  color: white;
}

.btn-qr {
  background: #24272A;
  color: white;
}

.btn-group {
  display: flex;
  gap: 8px;
  margin-top: 16px;
  flex-wrap: wrap;
}

.output {
  background: var(--bg);
  border: 2px dashed var(--border);
  border-radius: 10px;
  padding: 14px;
  min-height: 60px;
  word-break: break-all;
  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
  font-size: 12px;
  color: var(--text);
  margin-top: 16px;
}

.output.has-content {
  border-style: solid;
  border-color: var(--mm-green);
  background: var(--card);
}

.warn {
  color: var(--mm-orange);
  font-size: 12px;
  margin-top: 12px;
  padding: 10px;
  background: rgba(246, 133, 27, 0.1);
  border-radius: 8px;
}

.info {
  color: var(--mm-purple);
  font-size: 12px;
  margin-top: 12px;
  padding: 10px;
  background: rgba(139, 92, 246, 0.1);
  border-radius: 8px;
}

.foot {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
  color: var(--muted);
  font-size: 12px;
}

code {
  background: var(--bg);
  padding: 3px 8px;
  border-radius: 6px;
  font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
  font-size: 11px;
}

.toast {
  position: fixed;
  bottom: 32px;
  right: 32px;
  padding: 14px 24px;
  border-radius: 48px;
  background: var(--mm-green);
  color: white;
  font-weight: 600;
  transform: translateX(400px);
  transition: transform 0.3s ease;
  z-index: 1000;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
}

.toast.show { transform: translateX(0); }

.disclaimer {
  margin-top: 40px;
  padding: 24px;
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  box-shadow: var(--shadow);
}

.disclaimer h3 {
  font-size: 18px;
  margin: 0 0 16px;
  font-weight: 600;
}

.disclaimer ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.disclaimer li {
  padding: 10px 0;
  border-bottom: 1px solid var(--border);
  font-size: 14px;
  color: var(--muted);
}

.disclaimer li:last-child { border-bottom: none; }

.qr-wrap {
  margin-top: 16px;
  padding: 16px;
  border: 1px solid var(--border);
  border-radius: 12px;
  background: var(--bg);
  display: none;
}

.qr-wrap.show { display: block; }

.qr-row {
  display: flex;
  align-items: flex-start;
  gap: 16px;
  flex-wrap: wrap;
}

.qr-container {
  background: white;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid var(--border);
}

.qr-help {
  color: var(--muted);
  font-size: 12px;
  max-width: 320px;
}

.loading {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid var(--border);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.predict-result {
  margin-top: 12px;
  padding: 12px;
  background: var(--bg);
  border-radius: 8px;
  font-size: 13px;
  display: none;
  line-height: 1.8;
}

.predict-result.show { display: block; }

.predict-result strong {
  color: var(--accent);
}

.divider {
  text-align: center;
  margin: 12px 0;
  color: var(--muted);
  font-size: 13px;
}
  </style>
</head>

<body>
  <header class="header">
    <div class="header-content">
      <img src="https://images.ctfassets.net/clixtyxoaeas/1ezuBGezqfIeifWdVtwU4c/d970d4cdf13b163efddddd5709164d2e/MetaMask-icon-Fox.svg" alt="MetaMask" class="logo-img">
      <h1>MetaMask Deeplink Generator</h1>
    </div>
  </header>

  <main class="wrap">
    <section class="intro">
      <p>Generate deeplinks for MetaMask Home, Swap, Buy, and Predict Markets. Select your parameters and click Generate. Supports EVM, Solana, Bitcoin, and Tron. <strong>Now with live USD conversion and mUSD support!</strong></p>
    </section>

    <section class="grid">
      <!-- HOME CARD -->
      <article class="card">
        <h2>üè† Home</h2>

        <div class="btn-group">
          <button type="button" class="btn btn-primary" id="homeGenerateBtn">Generate</button>
          <button type="button" class="btn btn-copy" id="homeCopyBtn">Copy</button>
          <button type="button" class="btn btn-qr" id="homeQrBtn">QR</button>
          <button type="button" class="btn btn-reset" id="homeResetBtn">Reset</button>
        </div>

        <div class="output" id="homeOutput"></div>

        <div class="qr-wrap" id="homeQrWrap">
          <div class="qr-row">
            <div class="qr-container" id="homeQrContainer"></div>
            <div class="qr-help">Scan on mobile to open the deeplink. If MetaMask is not installed, you may be routed to a download page.</div>
          </div>
        </div>

        <div class="foot">Base: <code>https://link.metamask.io/home</code></div>
      </article>

      <!-- SWAP CARD -->
      <article class="card">
        <h2>üîÑ Swap</h2>

        <div class="row">
          <div>
            <label for="fromChainSelect">From Chain</label>
            <select id="fromChainSelect"></select>
          </div>
          <div>
            <label for="fromTokenSelect">From Token</label>
            <select id="fromTokenSelect"></select>
          </div>
        </div>

        <div class="row">
          <div>
            <label for="toChainSelect">To Chain</label>
            <select id="toChainSelect"></select>
          </div>
          <div>
            <label for="toTokenSelect">To Token</label>
            <select id="toTokenSelect"></select>
          </div>
        </div>

        <div class="row">
          <div>
            <label for="amountInput">Amount</label>
            <div class="input-with-toggle">
              <input type="number" id="amountInput" min="0" step="any" placeholder="e.g., 1.5">
              <button type="button" class="currency-toggle" id="swapCurrencyToggle">USD</button>
            </div>
            <div class="conversion-info" id="swapConversionInfo"></div>
          </div>
          <div>
            <label>Base Units (auto)</label>
            <input type="text" id="baseUnitsDisplay" readonly placeholder="Calculated">
          </div>
        </div>

        <div class="btn-group">
          <button type="button" class="btn btn-primary" id="swapGenerateBtn">Generate</button>
          <button type="button" class="btn btn-copy" id="swapCopyBtn">Copy</button>
          <button type="button" class="btn btn-qr" id="swapQrBtn">QR</button>
          <button type="button" class="btn btn-reset" id="swapResetBtn">Reset</button>
        </div>

        <div class="output" id="swapOutput"></div>

        <div class="qr-wrap" id="swapQrWrap">
          <div class="qr-row">
            <div class="qr-container" id="swapQrContainer"></div>
            <div class="qr-help">If a given pair is not routable, MetaMask may show no route available. This generator still formats the deeplink parameters correctly.</div>
          </div>
        </div>

        <div class="warn">‚ö†Ô∏è Only verified token addresses included (where applicable). Cross chain routing depends on MetaMask support.</div>
        <div class="foot">Base: <code>https://link.metamask.io/swap</code></div>
      </article>

      <!-- BUY CARD -->
      <article class="card">
        <h2>üí≥ Buy</h2>

        <div>
          <label for="buyChainSelect">Chain</label>
          <select id="buyChainSelect"></select>
        </div>

        <div>
          <label for="buyTokenSelect">Token</label>
          <select id="buyTokenSelect"></select>
        </div>

        <div>
          <label for="buyAmountInput">Amount (optional)</label>
          <div class="input-with-toggle">
            <input type="number" id="buyAmountInput" min="0" step="any" placeholder="e.g., 5">
            <button type="button" class="currency-toggle" id="buyCurrencyToggle">USD</button>
          </div>
          <div class="conversion-info" id="buyConversionInfo"></div>
        </div>

        <div class="btn-group">
          <button type="button" class="btn btn-primary" id="buyGenerateBtn">Generate</button>
          <button type="button" class="btn btn-copy" id="buyCopyBtn">Copy</button>
          <button type="button" class="btn btn-qr" id="buyQrBtn">QR</button>
          <button type="button" class="btn btn-reset" id="buyResetBtn">Reset</button>
        </div>

        <div class="output" id="buyOutput"></div>

        <div class="qr-wrap" id="buyQrWrap">
          <div class="qr-row">
            <div class="qr-container" id="buyQrContainer"></div>
            <div class="qr-help">Use QR for quick handoff to mobile, especially when you are generating links on desktop.</div>
          </div>
        </div>

        <div class="foot">Base: <code>https://link.metamask.io/buy</code></div>
      </article>

      <!-- PREDICT CARD -->
      <article class="card">
        <h2>üîÆ Predict</h2>

        <div>
          <label for="predictUrlInput">Polymarket URL</label>
          <textarea id="predictUrlInput" placeholder="https://polymarket.com/event/will-the-supreme-court-rule-in-favor-of-trumps-tariffs"></textarea>
        </div>

        <div class="divider">
          <strong>‚Äî OR ‚Äî</strong>
        </div>

        <div>
          <label for="predictIdInput">Market ID (direct entry)</label>
          <input type="text" id="predictIdInput" placeholder="e.g., 67691">
        </div>

        <div class="predict-result" id="predictResult"></div>

        <div class="btn-group">
          <button type="button" class="btn btn-primary" id="predictGenerateBtn">Generate</button>
          <button type="button" class="btn btn-copy" id="predictCopyBtn">Copy</button>
          <button type="button" class="btn btn-qr" id="predictQrBtn">QR</button>
          <button type="button" class="btn btn-reset" id="predictResetBtn">Reset</button>
        </div>

        <div class="output" id="predictOutput"></div>

        <div class="qr-wrap" id="predictQrWrap">
          <div class="qr-row">
            <div class="qr-container" id="predictQrContainer"></div>
            <div class="qr-help">Links to specific prediction markets on Polymarket through MetaMask.</div>
          </div>
        </div>

        <div class="info">üí° Paste the full Polymarket URL or enter the market ID directly. The slug will be automatically extracted from the URL.</div>
        <div class="foot">Base: <code>https://link.metamask.io/predict?marketId=</code></div>
      </article>
    </section>

    <section class="disclaimer">
      <h3>üìã Important Information</h3>
      <ul>
        <li><strong>Routing:</strong> Desktop with Extension ‚Üí opens Extension. Mobile with app ‚Üí opens app. Otherwise ‚Üí download page.</li>
        <li><strong>Versions:</strong> Home: Ext ‚â•12.23.0, Mobile ‚â•7.51.0 | Swap: Ext ‚â•13.0.0, Mobile ‚â•7.51.0 | Predict: Latest versions</li>
        <li><strong>Predict Markets:</strong> Uses Polymarket's Gamma API to fetch market IDs. Requires valid market slug or direct ID.</li>
        <li><strong>USD Conversion:</strong> Live prices from CoinGecko API. Click USD/Crypto toggle to switch input mode.</li>
        <li><strong>mUSD:</strong> MetaMask USD stablecoin available on Ethereum network (18 decimals).</li>
      </ul>
    </section>
  </main>

  <div class="toast" id="toast"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <script>
    // ===== DATA =====
    var CHAINS = [
      // EVM
      { key: 'ethereum', label: 'Ethereum', type: 'evm', ns: 'eip155', chainId: '1', slip: 60 },
      { key: 'polygon', label: 'Polygon', type: 'evm', ns: 'eip155', chainId: '137', slip: 966 },
      { key: 'base', label: 'Base', type: 'evm', ns: 'eip155', chainId: '8453', slip: 60 },
      { key: 'arbitrum', label: 'Arbitrum', type: 'evm', ns: 'eip155', chainId: '42161', slip: 60 },
      { key: 'optimism', label: 'Optimism', type: 'evm', ns: 'eip155', chainId: '10', slip: 60 },
      { key: 'avalanche', label: 'Avalanche', type: 'evm', ns: 'eip155', chainId: '43114', slip: 9005 },
      { key: 'bsc', label: 'BNB Chain', type: 'evm', ns: 'eip155', chainId: '56', slip: 714 },
      { key: 'linea', label: 'Linea', type: 'evm', ns: 'eip155', chainId: '59144', slip: 60 },

      // Solana
      { key: 'solana', label: 'Solana', type: 'solana', ns: 'solana', chainId: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp', slip: 501 },

      // Bitcoin
      { key: 'bitcoin', label: 'Bitcoin', type: 'bitcoin', ns: 'bip122', chainId: '000000000019d6689c085ae165831e93', slip: 0 },

      // Tron
      { key: 'tron', label: 'Tron', type: 'tron', ns: 'tron', chainId: '728126428', slip: 195 }
    ];

    var TOKENS = {
      ethereum: [
        { sym: 'ETH', type: 'slip44', addr: '60', dec: 18, coingeckoId: 'ethereum' },
        { sym: 'mUSD', type: 'erc20', addr: '0xacA92E438df0B2401fF60dA7E4337B687a2435DA', dec: 18, coingeckoId: 'usd-coin' },
        { sym: 'USDC', type: 'erc20', addr: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', dec: 6, coingeckoId: 'usd-coin' },
        { sym: 'USDT', type: 'erc20', addr: '0xdAC17F958D2ee523a2206206994597C13D831ec7', dec: 6, coingeckoId: 'tether' },
        { sym: 'DAI', type: 'erc20', addr: '0x6B175474E89094C44Da98b954EedeAC495271d0F', dec: 18, coingeckoId: 'dai' },
        { sym: 'WETH', type: 'erc20', addr: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', dec: 18, coingeckoId: 'weth' },
        { sym: 'WBTC', type: 'erc20', addr: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', dec: 8, coingeckoId: 'wrapped-bitcoin' }
      ],
      polygon: [
        { sym: 'POL', type: 'slip44', addr: '966', dec: 18, coingeckoId: 'matic-network' },
        { sym: 'USDC', type: 'erc20', addr: '0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359', dec: 6, coingeckoId: 'usd-coin' },
        { sym: 'USDT', type: 'erc20', addr: '0xc2132D05D31c914a87C6611C10748AEb04B58e8F', dec: 6, coingeckoId: 'tether' },
        { sym: 'WETH', type: 'erc20', addr: '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619', dec: 18, coingeckoId: 'weth' }
      ],
      base: [
        { sym: 'ETH', type: 'slip44', addr: '60', dec: 18, coingeckoId: 'ethereum' },
        { sym: 'USDC', type: 'erc20', addr: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913', dec: 6, coingeckoId: 'usd-coin' }
      ],
      arbitrum: [
        { sym: 'ETH', type: 'slip44', addr: '60', dec: 18, coingeckoId: 'ethereum' },
        { sym: 'USDC', type: 'erc20', addr: '0xAf88d065e77c8cC2239327C5EDb3A432268e5831', dec: 6, coingeckoId: 'usd-coin' },
        { sym: 'ARB', type: 'erc20', addr: '0x912CE59144191C1204E64559FE8253a0e49E6548', dec: 18, coingeckoId: 'arbitrum' }
      ],
      optimism: [
        { sym: 'ETH', type: 'slip44', addr: '60', dec: 18, coingeckoId: 'ethereum' },
        { sym: 'USDC', type: 'erc20', addr: '0x0b2c639c533813f4aa9d7837caf62653d097ff85', dec: 6, coingeckoId: 'usd-coin' },
        { sym: 'OP', type: 'erc20', addr: '0x4200000000000000000000000000000000000042', dec: 18, coingeckoId: 'optimism' }
      ],
      avalanche: [
        { sym: 'AVAX', type: 'slip44', addr: '9005', dec: 18, coingeckoId: 'avalanche-2' },
        { sym: 'USDC', type: 'erc20', addr: '0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E', dec: 6, coingeckoId: 'usd-coin' }
      ],
      bsc: [
        { sym: 'BNB', type: 'slip44', addr: '714', dec: 18, coingeckoId: 'binancecoin' },
        { sym: 'USDT', type: 'erc20', addr: '0x55d398326f99059fF775485246999027B3197955', dec: 18, coingeckoId: 'tether' }
      ],
      linea: [
        { sym: 'ETH', type: 'slip44', addr: '60', dec: 18, coingeckoId: 'ethereum' },
        { sym: 'USDC', type: 'erc20', addr: '0x176211869cA2b568f2A7D4EE941E073a821EE1ff', dec: 6, coingeckoId: 'usd-coin' }
      ],
      solana: [
        { sym: 'SOL', type: 'slip44', addr: '501', dec: 9, coingeckoId: 'solana' },
        { sym: 'USDC', type: 'spl', addr: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', dec: 6, coingeckoId: 'usd-coin' },
        { sym: 'USDT', type: 'spl', addr: 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', dec: 6, coingeckoId: 'tether' }
      ],
      bitcoin: [
        { sym: 'BTC', type: 'slip44', addr: '0', dec: 8, coingeckoId: 'bitcoin' }
      ],
      tron: [
        { sym: 'TRX', type: 'slip44', addr: '195', dec: 6, coingeckoId: 'tron' },
        { sym: 'USDT', type: 'trc20', addr: 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t', dec: 6, coingeckoId: 'tether' },
        { sym: 'USDC', type: 'trc20', addr: 'TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8', dec: 6, coingeckoId: 'usd-coin' }
      ]
    };

    // Price cache
    var priceCache = {};
    var cacheTimeout = 60000; // 1 minute

    // ===== HELPERS =====
    function getEl(id) { return document.getElementById(id); }

    function showToast(msg) {
      var toast = getEl('toast');
      toast.textContent = msg;
      toast.classList.add('show');
      setTimeout(function() { toast.classList.remove('show'); }, 2500);
    }

    function copyText(text) {
      if (!text) { showToast('Nothing to copy!'); return; }
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(function() { showToast('Copied!'); })
          .catch(function() { showToast('Copy failed'); });
      } else {
        var ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.opacity = '0';
        document.body.appendChild(ta);
        ta.select();
        try { document.execCommand('copy'); showToast('Copied!'); }
        catch (e) { showToast('Copy failed'); }
        document.body.removeChild(ta);
      }
    }

    function toBaseUnits(amount, decimals) {
      if (!amount || isNaN(parseFloat(amount))) return '';
      var num = parseFloat(amount);
      if (num < 0) return '';

      if (String(amount).toLowerCase().indexOf('e') !== -1) return '';

      var parts = String(amount).split('.');
      var intPart = parts[0] || '0';
      var fracPart = parts[1] || '';
      fracPart = (fracPart + '0'.repeat(decimals)).slice(0, decimals);

      var result = (intPart.replace(/\D/g, '') + fracPart.replace(/\D/g, '')).replace(/^0+/, '');
      return result || '0';
    }

    function getChain(key) {
      for (var i = 0; i < CHAINS.length; i++) {
        if (CHAINS[i].key === key) return CHAINS[i];
      }
      return null;
    }

    function populateChains(selectEl) {
      selectEl.innerHTML = '';
      for (var i = 0; i < CHAINS.length; i++) {
        var opt = document.createElement('option');
        opt.value = CHAINS[i].key;
        opt.textContent = CHAINS[i].label;
        selectEl.appendChild(opt);
      }
    }

    function populateTokens(selectEl, chainKey) {
      selectEl.innerHTML = '';
      var tokens = TOKENS[chainKey] || [];
      for (var i = 0; i < tokens.length; i++) {
        var opt = document.createElement('option');
        opt.value = i;
        opt.textContent = tokens[i].sym;
        selectEl.appendChild(opt);
      }
      if (tokens.length === 0) {
        var opt2 = document.createElement('option');
        opt2.value = '';
        opt2.textContent = '(none)';
        selectEl.appendChild(opt2);
      }
    }

    function getNamespaceString(chain) {
      return chain.ns + ':' + chain.chainId;
    }

    function getAssetString(token, context) {
      if (token.type === 'native') {
        if (context === 'swap') return 'native';
        if (context === 'buy') return 'slip44:' + token.addr;
      }
      if (token.type === 'slip44') return 'slip44:' + token.addr;
      if (token.type === 'erc20') return 'erc20:' + token.addr;
      if (token.type === 'spl') return 'spl:' + token.addr;
      if (token.type === 'trc20') return 'trc20:' + token.addr;
      return '';
    }

    function clearQr(containerId) {
      var container = getEl(containerId);
      if (container) {
        container.innerHTML = '';
      }
    }

    function renderQr(containerId, wrapId, text) {
      var container = getEl(containerId);
      var wrap = getEl(wrapId);
      if (!container || !wrap) return;

      if (!text) {
        clearQr(containerId);
        wrap.classList.remove('show');
        return;
      }

      wrap.classList.add('show');
      container.innerHTML = '';

      try {
        new QRCode(container, {
          text: text,
          width: 196,
          height: 196,
          colorDark: '#000000',
          colorLight: '#ffffff',
          correctLevel: QRCode.CorrectLevel.M
        });
      } catch (e) {
        console.error('QR Exception:', e);
        showToast('QR generation failed');
      }
    }

    // ===== PRICE API =====
    async function fetchCryptoPrice(coingeckoId) {
      try {
        var now = Date.now();
        if (priceCache[coingeckoId] && (now - priceCache[coingeckoId].timestamp < cacheTimeout)) {
          return priceCache[coingeckoId].price;
        }

        var apiUrl = 'https://api.coingecko.com/api/v3/simple/price?ids=' + coingeckoId + '&vs_currencies=usd';
        var response = await fetch(apiUrl);
        
        if (!response.ok) {
          throw new Error('Price fetch failed');
        }
        
        var data = await response.json();
        
        if (data && data[coingeckoId] && data[coingeckoId].usd) {
          var price = data[coingeckoId].usd;
          priceCache[coingeckoId] = {
            price: price,
            timestamp: now
          };
          return price;
        } else {
          throw new Error('Price not found');
        }
      } catch (error) {
        console.error('Price fetch error:', error);
        return null;
      }
    }

    function convertUsdToCrypto(usdAmount, cryptoPrice) {
      if (!cryptoPrice || cryptoPrice === 0) return null;
      return usdAmount / cryptoPrice;
    }

    function convertCryptoToUsd(cryptoAmount, cryptoPrice) {
      if (!cryptoPrice) return null;
      return cryptoAmount * cryptoPrice;
    }

    // ===== POLYMARKET API =====
    function extractSlugFromUrl(url) {
      try {
        var cleanUrl = url.trim();
        
        if (cleanUrl.includes('polymarket.com/event/')) {
          var parts = cleanUrl.split('/event/');
          if (parts.length > 1) {
            var slug = parts[1].split('?')[0].split('#')[0].replace(/\/$/, '');
            return slug;
          }
        }
        
        if (!cleanUrl.includes('/') && !cleanUrl.includes('http')) {
          return cleanUrl;
        }
        
        throw new Error('Invalid URL format');
      } catch (error) {
        throw new Error('Could not extract slug from URL');
      }
    }

    async function fetchMarketId(slug) {
      try {
        var cleanSlug = slug.trim();
        
        var apiUrl = 'https://gamma-api.polymarket.com/events?slug=' + encodeURIComponent(cleanSlug);
        var proxyUrl = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(apiUrl);
        
        var response = await fetch(proxyUrl);
        
        if (!response.ok) {
          throw new Error('API request failed');
        }
        
        var data = await response.json();
        
        if (data && data.length > 0 && data[0].id) {
          return { 
            id: data[0].id, 
            title: data[0].title || cleanSlug,
            slug: cleanSlug 
          };
        } else {
          throw new Error('Market not found');
        }
      } catch (error) {
        console.error('Polymarket API Error:', error);
        throw error;
      }
    }

    // ===== HOME =====
    function initHome() {
      var genBtn = getEl('homeGenerateBtn');
      var copyBtn = getEl('homeCopyBtn');
      var qrBtn = getEl('homeQrBtn');
      var resetBtn = getEl('homeResetBtn');
      var output = getEl('homeOutput');

      genBtn.addEventListener('click', function() {
        var url = 'https://link.metamask.io/home';
        output.textContent = url;
        output.classList.add('has-content');
        renderQr('homeQrContainer', 'homeQrWrap', url);
        showToast('Home deeplink generated!');
      });

      copyBtn.addEventListener('click', function() { copyText(output.textContent); });

      qrBtn.addEventListener('click', function() {
        var url = output.textContent || '';
        if (!url) { showToast('Generate a link first'); return; }
        renderQr('homeQrContainer', 'homeQrWrap', url);
        showToast('QR ready');
      });

      resetBtn.addEventListener('click', function() {
        output.textContent = '';
        output.classList.remove('has-content');
        renderQr('homeQrContainer', 'homeQrWrap', '');
        showToast('Reset!');
      });
    }

    // ===== SWAP =====
    function initSwap() {
      var fromChain = getEl('fromChainSelect');
      var fromToken = getEl('fromTokenSelect');
      var toChain = getEl('toChainSelect');
      var toToken = getEl('toTokenSelect');
      var amountInput = getEl('amountInput');
      var baseDisplay = getEl('baseUnitsDisplay');
      var currencyToggle = getEl('swapCurrencyToggle');
      var conversionInfo = getEl('swapConversionInfo');
      var genBtn = getEl('swapGenerateBtn');
      var copyBtn = getEl('swapCopyBtn');
      var qrBtn = getEl('swapQrBtn');
      var resetBtn = getEl('swapResetBtn');
      var output = getEl('swapOutput');

      var isUsdMode = false;

      populateChains(fromChain);
      populateChains(toChain);

      fromChain.value = 'ethereum';
      toChain.value = 'polygon';

      populateTokens(fromToken, fromChain.value);
      populateTokens(toToken, toChain.value);

      fromChain.addEventListener('change', function() {
        populateTokens(fromToken, fromChain.value);
      });

      toChain.addEventListener('change', function() {
        populateTokens(toToken, toChain.value);
      });

      currencyToggle.addEventListener('click', function() {
        isUsdMode = !isUsdMode;
        currencyToggle.textContent = isUsdMode ? 'Crypto' : 'USD';
        amountInput.placeholder = isUsdMode ? 'e.g., 100 (USD)' : 'e.g., 1.5';
        conversionInfo.textContent = '';
        amountInput.value = '';
      });

      amountInput.addEventListener('input', async function() {
        if (!amountInput.value || !isUsdMode) {
          conversionInfo.textContent = '';
          return;
        }

        var ftTokens = TOKENS[fromChain.value] || [];
        var ftIdx = parseInt(fromToken.value);
        if (isNaN(ftIdx) || !ftTokens[ftIdx] || !ftTokens[ftIdx].coingeckoId) {
          conversionInfo.textContent = '';
          return;
        }

        var token = ftTokens[ftIdx];
        conversionInfo.textContent = 'Fetching price...';
        
        var price = await fetchCryptoPrice(token.coingeckoId);
        if (price) {
          var cryptoAmount = convertUsdToCrypto(parseFloat(amountInput.value), price);
          if (cryptoAmount) {
            conversionInfo.textContent = '‚âà ' + cryptoAmount.toFixed(6) + ' ' + token.sym + ' ($' + price.toLocaleString() + ' per ' + token.sym + ')';
          }
        } else {
          conversionInfo.textContent = 'Price unavailable';
        }
      });

      genBtn.addEventListener('click', async function() {
        var fc = getChain(fromChain.value);
        var tc = getChain(toChain.value);
        if (!fc || !tc) { showToast('Please select valid chains'); return; }

        var ftTokens = TOKENS[fromChain.value] || [];
        var ttTokens = TOKENS[toChain.value] || [];

        var ftIdx = parseInt(fromToken.value);
        var ttIdx = parseInt(toToken.value);

        if (isNaN(ftIdx) || isNaN(ttIdx) || !ftTokens[ftIdx] || !ttTokens[ttIdx]) {
          showToast('Please select valid tokens');
          return;
        }

        var ft = ftTokens[ftIdx];
        var tt = ttTokens[ttIdx];

        var fromNs = getNamespaceString(fc);
        var toNs = getNamespaceString(tc);

        var fromAsset = getAssetString(ft, 'swap');
        var toAsset = getAssetString(tt, 'swap');

        if (!fromAsset || !toAsset) {
          showToast('Invalid asset format for selected tokens');
          return;
        }

        var params = [];
        
        var amt = amountInput.value;
        if (amt && parseFloat(amt) > 0) {
          var actualAmount = amt;
          
          if (isUsdMode && ft.coingeckoId) {
            var price = await fetchCryptoPrice(ft.coingeckoId);
            if (price) {
              actualAmount = convertUsdToCrypto(parseFloat(amt), price);
            } else {
              showToast('Could not fetch price. Try crypto mode.');
              return;
            }
          }
          
          var base = toBaseUnits(actualAmount, ft.dec);
          if (!base) { showToast('Invalid amount'); return; }
          baseDisplay.value = base;
          params.push('amount=' + encodeURIComponent(base));
        } else {
          baseDisplay.value = '';
        }

        params.push('from=' + encodeURIComponent(fromNs + '/' + fromAsset));
        params.push('to=' + encodeURIComponent(toNs + '/' + toAsset));

        var url = 'https://link.metamask.io/swap?' + params.join('&');

        output.textContent = url;
        output.classList.add('has-content');
        renderQr('swapQrContainer', 'swapQrWrap', url);
        showToast('Swap deeplink generated!');
      });

      copyBtn.addEventListener('click', function() { copyText(output.textContent); });

      qrBtn.addEventListener('click', function() {
        var url = output.textContent || '';
        if (!url) { showToast('Generate a link first'); return; }
        renderQr('swapQrContainer', 'swapQrWrap', url);
        showToast('QR ready');
      });

      resetBtn.addEventListener('click', function() {
        fromChain.value = 'ethereum';
        toChain.value = 'polygon';
        populateTokens(fromToken, 'ethereum');
        populateTokens(toToken, 'polygon');
        amountInput.value = '';
        baseDisplay.value = '';
        conversionInfo.textContent = '';
        isUsdMode = false;
        currencyToggle.textContent = 'USD';
        output.textContent = '';
        output.classList.remove('has-content');
        renderQr('swapQrContainer', 'swapQrWrap', '');
        showToast('Reset!');
      });
    }

    // ===== BUY =====
    function initBuy() {
      var chainSelect = getEl('buyChainSelect');
      var tokenSelect = getEl('buyTokenSelect');
      var amountInput = getEl('buyAmountInput');
      var currencyToggle = getEl('buyCurrencyToggle');
      var conversionInfo = getEl('buyConversionInfo');
      var genBtn = getEl('buyGenerateBtn');
      var copyBtn = getEl('buyCopyBtn');
      var qrBtn = getEl('buyQrBtn');
      var resetBtn = getEl('buyResetBtn');
      var output = getEl('buyOutput');

      var isUsdMode = false;

      populateChains(chainSelect);
      chainSelect.value = 'ethereum';
      populateTokens(tokenSelect, chainSelect.value);

      chainSelect.addEventListener('change', function() {
        populateTokens(tokenSelect, chainSelect.value);
      });

      currencyToggle.addEventListener('click', function() {
        isUsdMode = !isUsdMode;
        currencyToggle.textContent = isUsdMode ? 'Crypto' : 'USD';
        amountInput.placeholder = isUsdMode ? 'e.g., 100 (USD)' : 'e.g., 5';
        conversionInfo.textContent = '';
        amountInput.value = '';
      });

      amountInput.addEventListener('input', async function() {
        if (!amountInput.value || !isUsdMode) {
          conversionInfo.textContent = '';
          return;
        }

        var tokens = TOKENS[chainSelect.value] || [];
        var tokenIdx = parseInt(tokenSelect.value);
        if (isNaN(tokenIdx) || !tokens[tokenIdx] || !tokens[tokenIdx].coingeckoId) {
          conversionInfo.textContent = '';
          return;
        }

        var token = tokens[tokenIdx];
        conversionInfo.textContent = 'Fetching price...';
        
        var price = await fetchCryptoPrice(token.coingeckoId);
        if (price) {
          var cryptoAmount = convertUsdToCrypto(parseFloat(amountInput.value), price);
          if (cryptoAmount) {
            conversionInfo.textContent = '‚âà ' + cryptoAmount.toFixed(6) + ' ' + token.sym + ' ($' + price.toLocaleString() + ' per ' + token.sym + ')';
          }
        } else {
          conversionInfo.textContent = 'Price unavailable';
        }
      });

      genBtn.addEventListener('click', async function() {
        var chain = getChain(chainSelect.value);
        if (!chain) { showToast('Please select a valid chain'); return; }

        var tokens = TOKENS[chainSelect.value] || [];
        var tokenIdx = parseInt(tokenSelect.value);
        
        if (isNaN(tokenIdx) || !tokens[tokenIdx]) {
          showToast('Please select a valid token');
          return;
        }

        var token = tokens[tokenIdx];
        var ns = getNamespaceString(chain);
        var asset = getAssetString(token, 'buy');

        if (!asset) {
          showToast('Invalid asset format');
          return;
        }

        var params = [];

        var amt = amountInput.value;
        if (amt && parseFloat(amt) > 0) {
          var actualAmount = amt;
          
          if (isUsdMode && token.coingeckoId) {
            var price = await fetchCryptoPrice(token.coingeckoId);
            if (price) {
              actualAmount = convertUsdToCrypto(parseFloat(amt), price);
            } else {
              showToast('Could not fetch price. Try crypto mode.');
              return;
            }
          }
          
          params.push('amount=' + encodeURIComponent(actualAmount));
        }

        params.push('assetId=' + encodeURIComponent(ns + '/' + asset));

        var url = 'https://link.metamask.io/buy?' + params.join('&');

        output.textContent = url;
        output.classList.add('has-content');
        renderQr('buyQrContainer', 'buyQrWrap', url);
        showToast('Buy deeplink generated!');
      });

      copyBtn.addEventListener('click', function() { copyText(output.textContent); });

      qrBtn.addEventListener('click', function() {
        var url = output.textContent || '';
        if (!url) { showToast('Generate a link first'); return; }
        renderQr('buyQrContainer', 'buyQrWrap', url);
        showToast('QR ready');
      });

      resetBtn.addEventListener('click', function() {
        chainSelect.value = 'ethereum';
        populateTokens(tokenSelect, 'ethereum');
        amountInput.value = '';
        conversionInfo.textContent = '';
        isUsdMode = false;
        currencyToggle.textContent = 'USD';
        output.textContent = '';
        output.classList.remove('has-content');
        renderQr('buyQrContainer', 'buyQrWrap', '');
        showToast('Reset!');
      });
    }

    // ===== PREDICT =====
    function initPredict() {
      var urlInput = getEl('predictUrlInput');
      var idInput = getEl('predictIdInput');
      var resultDiv = getEl('predictResult');
      var genBtn = getEl('predictGenerateBtn');
      var copyBtn = getEl('predictCopyBtn');
      var qrBtn = getEl('predictQrBtn');
      var resetBtn = getEl('predictResetBtn');
      var output = getEl('predictOutput');

      genBtn.addEventListener('click', async function() {
        var urlOrSlug = urlInput.value.trim();
        var directId = idInput.value.trim();

        if (directId) {
          var url = 'https://link.metamask.io/predict?marketId=' + encodeURIComponent(directId);
          output.textContent = url;
          output.classList.add('has-content');
          renderQr('predictQrContainer', 'predictQrWrap', url);
          resultDiv.innerHTML = '<strong>Using Market ID:</strong> ' + directId;
          resultDiv.classList.add('show');
          showToast('Predict deeplink generated!');
          return;
        }

        if (!urlOrSlug) {
          showToast('Please enter a Polymarket URL or Market ID');
          return;
        }

        genBtn.disabled = true;
        genBtn.innerHTML = '<span class="loading"></span> Fetching...';
        resultDiv.classList.remove('show');

        try {
          var slug = extractSlugFromUrl(urlOrSlug);
          
          resultDiv.innerHTML = '<strong>Extracted Slug:</strong> ' + slug + '<br><span class="loading"></span> Fetching market data...';
          resultDiv.classList.add('show');

          var marketData = await fetchMarketId(slug);
          
          resultDiv.innerHTML = '<strong>Market Found!</strong><br>' +
                               '<strong>Title:</strong> ' + marketData.title + '<br>' +
                               '<strong>Slug:</strong> ' + marketData.slug + '<br>' +
                               '<strong>ID:</strong> ' + marketData.id;
          resultDiv.classList.add('show');

          var url = 'https://link.metamask.io/predict?marketId=' + encodeURIComponent(marketData.id);
          output.textContent = url;
          output.classList.add('has-content');
          renderQr('predictQrContainer', 'predictQrWrap', url);
          showToast('Predict deeplink generated!');
        } catch (error) {
          showToast('Failed to generate deeplink');
          var errorMsg = '<strong>Error:</strong> ' + error.message + '<br><br>';
          
          if (error.message === 'Could not extract slug from URL') {
            errorMsg += '<strong>Tip:</strong> Make sure you paste the full URL like:<br>' +
                       '<code>https://polymarket.com/event/your-market-slug</code>';
          } else {
            errorMsg += '<strong>Manual steps:</strong><br>' +
                       '1. Extract the slug from your URL (the part after /event/)<br>' +
                       '2. Visit <code>https://gamma-api.polymarket.com/events?slug=YOUR-SLUG</code><br>' +
                       '3. Find the "id" field in the response<br>' +
                       '4. Enter it in the Market ID field above';
          }
          
          resultDiv.innerHTML = errorMsg;
          resultDiv.classList.add('show');
        } finally {
          genBtn.disabled = false;
          genBtn.textContent = 'Generate';
        }
      });

      copyBtn.addEventListener('click', function() { copyText(output.textContent); });

      qrBtn.addEventListener('click', function() {
        var url = output.textContent || '';
        if (!url) { showToast('Generate a link first'); return; }
        renderQr('predictQrContainer', 'predictQrWrap', url);
        showToast('QR ready');
      });

      resetBtn.addEventListener('click', function() {
        urlInput.value = '';
        idInput.value = '';
        output.textContent = '';
        output.classList.remove('has-content');
        resultDiv.classList.remove('show');
        resultDiv.innerHTML = '';
        renderQr('predictQrContainer', 'predictQrWrap', '');
        showToast('Reset!');
      });
    }

    // ===== INIT =====
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(function() {
        if (typeof QRCode !== 'undefined') {
          initHome();
          initSwap();
          initBuy();
          initPredict();
        } else {
          console.error('QRCode library failed to load');
          showToast('QR functionality unavailable');
        }
      }, 100);
    });
  </script>
</body>
</html>
